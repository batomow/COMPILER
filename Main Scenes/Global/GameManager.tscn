[gd_scene load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

class_name GameManager
signal game_paused
signal game_unpaused

enum difficulty { easy = 3, normal = 6, hard = 9}
# warning-ignore:unused_class_variable
export (difficulty) var DIFFICULTY
enum EFUGA {SPAWN = 0, HELD = 1, PATCH = 2}

enum game_states { PAUSED, NOT_PAUSED, TIMEOUT } 
var current_state:int = game_states.NOT_PAUSED setget _state_check

var flood_level:float = 0
var emptying_velocity:float = 0

var small_leaks:int = 0
var big_leaks:int = 0

const EMPTYING_AMOUNT := 0.24
const BIG_LEAK := 0.02
const SMALL_LEAK := 0.01

var reloj:Reloj
var toolbox:ToolBox
var game_root:Game_Root

func _process(delta): 
	flood_level = clamp(flood_level + (big_leaks * BIG_LEAK + small_leaks * SMALL_LEAK - emptying_velocity * EMPTYING_AMOUNT) * delta, 0, INF)

func change_to_small_leak():
	big_leaks -= 1
	small_leaks += 1

func change_to_big_leak():
	big_leaks += 1
# warning-ignore:narrowing_conversion
	small_leaks = clamp(small_leaks - 1, 0, INF)

func delete_leak(leak):
	big_leaks -= 1
	game_root.delete_fuga(leak)

func _state_check(value): 
	current_state = value
	if current_state == game_states.TIMEOUT: 
		print(\"Game Over\")
	elif current_state == game_states.NOT_PAUSED: 
		reloj.unpause_timers()
		emit_signal(\"game_unpaused\")
	elif current_state == game_states.PAUSED: 
		reloj.pause_timers()
		emit_signal(\"game_paused\")"

[node name="GameManager" type="Node"]
script = SubResource( 1 )
DIFFICULTY = 9
